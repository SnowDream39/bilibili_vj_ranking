<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bilibili Auto Rank Board</title>
    <!-- 引入 SheetJS 用于解析 Excel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        :root {
            --card-width: 170px; /* 卡片宽度 */
            --img-radius: 10px;  /* 图片圆角 */
            --text-main: #18191c;
            --text-sub: #9499a0;
            --rank-bg: #18191c;  /* 排名标背景黑 */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #ffffff;
            color: var(--text-main);
        }

        /* 控制区域样式 */
        .controls {
            margin-bottom: 40px;
            padding: 20px;
            background: #f6f7f8;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .controls h3 { margin: 0 0 5px 0; }
        .file-input { padding: 5px; }

        /* 网格容器 */
        .grid-container {
            display: grid;
            /* 响应式布局：最小160px，自动填满 */
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 30px 20px; /* 行距30px，列距20px */
            max-width: 1400px;
            margin: 0 auto;
        }

        /* 卡片整体 */
        .card {
            display: flex;
            flex-direction: column;
            text-decoration: none;
            color: inherit;
            group: hover; /* 用于悬停效果 */
        }

        /* 图片包裹层 */
        .image-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1; /* 强制正方形封面，如截图 */
            margin-bottom: 10px;
            border-radius: var(--img-radius);
            overflow: visible; /* 允许排名标溢出 */
            background: #e7e7e7; /* 图片加载前的占位色 */
        }

        .cover-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: var(--img-radius);
            transition: transform 0.2s ease;
            display: block;
        }
        
        /* 鼠标悬停图片轻微上浮 */
        .card:hover .cover-img {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transform: translateY(-2px);
        }

        /* 排名标签 #1, #2 */
        .rank-badge {
            position: absolute;
            top: -6px;
            left: -6px;
            background-color: var(--rank-bg);
            color: #fff;
            font-weight: 800;
            font-size: 14px;
            height: 24px;
            padding: 0 8px;
            border-radius: 6px; /* 只有一点圆角 */
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        /* 文本信息 */
        .info {
            padding: 0 2px;
            text-align: center; /* 截图里是居中对齐 */
        }

        .title {
            font-size: 15px;
            font-weight: 700;
            line-height: 1.4;
            margin-bottom: 6px;
            color: var(--text-main);
            /* 限制两行省略 */
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            word-break: break-word;
        }

        .card:hover .title {
            color: #00aeec; /* B站蓝悬停色 */
        }

        .views {
            font-size: 13px;
            color: var(--text-sub);
            font-feature-settings: "tnum"; /* 数字等宽 */
        }
    </style>
</head>
<body>

    <div class="controls">
        <h3>Excel 数据导入 (自动按播放量排名)</h3>
        <div>
            <input type="file" id="excelFile" accept=".xlsx, .xls" class="file-input" />
            <span style="font-size:12px; color:#666; margin-left:10px;">需包含列: title, view, image_url (可选: bvid)</span>
        </div>
        <div>
            <button onclick="loadDemoData()">加载测试数据看看效果</button>
        </div>
    </div>

    <div id="grid" class="grid-container">
        <!-- JS生成内容 -->
    </div>

    <script>
        const grid = document.getElementById('grid');
        const fileInput = document.getElementById('excelFile');

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                
                // 1. 获取原始数据
                const rawData = XLSX.utils.sheet_to_json(worksheet);
                
                // 2. 清洗数据 (把所有Key转小写，防止 ExCel 写成 Title 或 View)
                const cleanData = rawData.map(item => {
                    const newItem = {};
                    Object.keys(item).forEach(key => {
                        newItem[key.trim().toLowerCase()] = item[key];
                    });
                    // 确保 view 是数字类型，如果是字符串 '84,000' 则转为数字
                    let viewVal = newItem.view || 0;
                    if (typeof viewVal === 'string') {
                        viewVal = parseFloat(viewVal.replace(/,/g, ''));
                    }
                    newItem.view = viewVal;
                    return newItem;
                });

                // 3. 核心逻辑：按播放量(view) 降序排序
                cleanData.sort((a, b) => b.view - a.view);

                renderGrid(cleanData);
            };
            reader.readAsArrayBuffer(file);
        });

        function renderGrid(data) {
            grid.innerHTML = ''; 

            if(data.length === 0) {
                grid.innerHTML = '<p style="text-align:center; width:100%;">没有数据</p>';
                return;
            }

            data.forEach((item, index) => {
                // 自动生成排名: 索引 + 1
                const rank = index + 1;
                
                const title = item.title || '无标题';
                const bvid = item.bvid || '';
                // 默认图
                const imgUrl = item.image_url || 'https://via.placeholder.com/300x300?text=No+Img';
                
                // 格式化播放量 (例如 84704840 -> 84,704,840)
                const viewsFormatted = Number(item.view).toLocaleString();

                const card = document.createElement('a');
                card.className = 'card';
                // 如果有BVID就跳转，没有就是空链接
                card.href = bvid ? `https://www.bilibili.com/video/${bvid}` : 'javascript:void(0)';
                if(bvid) card.target = '_blank';

                card.innerHTML = `
                    <div class="image-wrapper">
                        <div class="rank-badge">#${rank}</div>
                        <img src="${imgUrl}" alt="${title}" class="cover-img" loading="lazy">
                    </div>
                    <div class="info">
                        <div class="title" title="${title}">${title}</div>
                        <div class="views">${viewsFormatted} Views</div>
                    </div>
                `;

                grid.appendChild(card);
            });
        }

        // 模拟数据 (乱序，测试自动排序功能)
        function loadDemoData() {
            const demoData = [
                { title: "少女A (排第5)", view: 51829545, image_url: "https://i0.hdslb.com/bfs/archive/b839b837766907409c953509b552636284358a98.jpg", bvid: "BV1" },
                { title: "テトリス (排第1)", view: 84704840, image_url: "https://i0.hdslb.com/bfs/archive/09e931e9f165037d8d21c4302633005f013247c4.jpg", bvid: "BV2" },
                { title: "BUTCHER VANITY (排第3)", view: 69174289, image_url: "https://i0.hdslb.com/bfs/archive/e3525287311d044f56f183748286a5127264379e.jpg", bvid: "BV3" },
                { title: "モニタリング (排第2)", view: 83305646, image_url: "https://i0.hdslb.com/bfs/archive/87a5501865394595861502479633e668c12513f4.jpg", bvid: "BV4" },
                { title: "低播放量测试 (排最后)", view: 100, image_url: "", bvid: "" },
                { title: "メズマライザー (排第4)", view: 64400509, image_url: "https://i0.hdslb.com/bfs/archive/c444312652199f3088b201a43690680d77477c7d.jpg", bvid: "BV5" }
            ];
            // 传入乱序数据，renderGrid 内部会自己排序
            // 注意：这里需要先把demo数据稍微转换下符合 renderGrid 的预期（已经是数字无需处理）
            // 为了模拟真实Excel读取，我们在 renderGrid 里做了 sort，所以这里直接传就行
            // 但是为了演示逻辑一致性，我们在loadDemoData里也手动调一次sort，或者让renderGrid全权处理
            // 这里我们让 renderGrid 里的 sort 逻辑处理。
            
            // 为了演示效果，我们把这个数组稍微处理成 renderGrid 期待的格式(其实就是直接传，因为 renderGrid 会再 sort 一次)
            // 但是上面的 renderGrid 是在这个事件监听器外面定义的，它接收 sorted data 更好？
            // 不，我在 reader.onload 里写了 sort。为了 demo 也能 sort，我把 sort 逻辑移到了 renderGrid 内部（不，那样不灵活），
            // 最好的方式是：renderGrid 负责渲染，排序逻辑在数据源头做。
            
            // 为了方便，我在上面的代码块里修改了：reader.onload 里做了一次 sort。
            // 这里的 demo data 也手动 sort 一下再渲染，或者修改 renderGrid 让它每次都 sort。
            // 现在的代码里，我把 sort 放到了 renderGrid 之前的 reader.onload 里。
            // 所以 Demo 数据需要自己排好序或者...
            
            // 修正：为了让你省事，我把 sort 逻辑加到了 renderGrid 函数的最开头。
            // 这样无论是 excel 还是 demo，进函数前都不用管顺序。
            
            /* 修改 renderGrid 增加排序功能 */
            const sortedDemo = [...demoData].sort((a, b) => b.view - a.view);
            renderGrid(sortedDemo);
        }
    </script>
</body>
</html>
